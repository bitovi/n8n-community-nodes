name: Publish

on:
  schedule:
    - cron: '0 * * * *' # Hourly at the top of each hour
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      force_publish:
        description: 'Force publish even if n8n version has not changed'
        required: false
        type: boolean
        default: false
      target_tag:
        description: 'Target tag for the Docker image'
        required: false
        type: string
        default: 'latest'

permissions:
  contents: read

jobs:
  check-version:
    runs-on: ubuntu-latest
    outputs:
      should_publish: ${{ steps.check.outputs.should_publish }}
      n8n_version: ${{ steps.check.outputs.n8n_version }}
      missing_versions: ${{ steps.check.outputs.missing_versions }}
    steps:
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_PASSWORD }}
      - name: Check for newer n8n base image
        id: check
        env:
          MY_IMAGE: bitovi/n8n-community-nodes
        run: |
          # Check if target_tag is a version number for manual workflow dispatch
          if [[ "${{ github.event_name }}" == "workflow_dispatch" && "${{ github.event.inputs.target_tag }}" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "Manual workflow dispatch with version tag detected: ${{ github.event.inputs.target_tag }}"
            echo "Using specified version as n8n version."
            echo "n8n_version=${{ github.event.inputs.target_tag }}" >> "$GITHUB_OUTPUT"
            echo "missing_versions=[\"${{ github.event.inputs.target_tag }}\"]" >> "$GITHUB_OUTPUT"
            echo "should_publish=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          
          echo "Getting all n8n semantic versions from Docker Hub..."
          
          # Get all semantic version tags from n8nio/n8n (checking multiple pages)
          # Note: Docker Hub API sorts by last_updated DESC, so latest versions are on page 1
          all_upstream_versions=$(
            for page in {1..10}; do
              response=$(curl -s "https://registry.hub.docker.com/v2/repositories/n8nio/n8n/tags/?page_size=100&page=$page")
              echo "$response" | jq -r '.results[].name'
              # Check if there's a next page
              if [ "$(echo "$response" | jq -r '.next')" == "null" ]; then
                break
              fi
            done | grep -E '^[0-9]+\.[0-9]+\.[0-9]+$' | sort -V -u
          )

          if [ -z "$all_upstream_versions" ]; then
            echo "::error::Failed to get n8n versions from Docker Hub. Halting."
            exit 1
          fi

          upstream_count=$(echo "$all_upstream_versions" | wc -l | tr -d ' ')
          latest_official_n8n=$(echo "$all_upstream_versions" | tail -1)
          echo "Found $upstream_count upstream versions"
          echo "Latest official n8n version on Docker Hub: $latest_official_n8n"
          echo "Last 5 upstream versions:"
          echo "$all_upstream_versions" | tail -5
          echo "n8n_version=${latest_official_n8n}" >> "$GITHUB_OUTPUT"

          echo "Getting all existing tags from our repository..."
          
          # Get all tags from our repository
          our_versions=$(
            for page in {1..10}; do
              response=$(curl -s "https://registry.hub.docker.com/v2/repositories/${MY_IMAGE}/tags/?page_size=100&page=$page")
              echo "$response" | jq -r '.results[].name'
              # Check if there's a next page
              if [ "$(echo "$response" | jq -r '.next')" == "null" ]; then
                break
              fi
            done | grep -E '^[0-9]+\.[0-9]+\.[0-9]+$' | sort -V -u
          )

          our_count=$(echo "$our_versions" | wc -l | tr -d ' ')
          echo "Found $our_count versions in our repository"
          if [ -n "$our_versions" ]; then
            echo "Last 5 versions in our repo:"
            echo "$our_versions" | tail -5
          else
            echo "Our repository has no semantic version tags yet"
            our_versions=""
          fi
          
          # Debug check: verify if latest upstream version exists in our repo
          if [ -n "$latest_official_n8n" ]; then
            if [ -n "$our_versions" ] && echo "$our_versions" | grep -q "^${latest_official_n8n}$"; then
              echo "✓ Latest version $latest_official_n8n already exists in our repo"
            else
              echo "✗ Latest version $latest_official_n8n is MISSING from our repo"
            fi
          fi

          # Find missing versions (versions in upstream but not in our repo)
          # Filter out very old versions (< 1.0.0) that may have compatibility issues
          missing_versions=()
          while IFS= read -r version; do
            if ! echo "$our_versions" | grep -q "^${version}$"; then
              # Skip versions older than 1.0.0 (pre-2024 versions with compatibility issues)
              if [[ $(echo -e "1.0.0\n$version" | sort -V | head -1) == "1.0.0" ]]; then
                missing_versions+=("$version")
              else
                echo "Skipping old version $version (< 1.0.0)"
              fi
            fi
          done <<< "$all_upstream_versions"

          if [ ${#missing_versions[@]} -eq 0 ]; then
            echo "No missing versions found. All upstream versions are published."
            echo "missing_versions=[]" >> "$GITHUB_OUTPUT"
            echo "should_publish=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Build a smart list: always include the latest version, plus up to 4 oldest versions
          # This ensures we catch the newest release immediately while still backfilling old ones
          missing_versions_limited=()
          
          if [ ${#missing_versions[@]} -eq 1 ]; then
            # Only one missing version
            missing_versions_limited=("${missing_versions[@]}")
          else
            # Get the newest version (always included)
            newest_version="${missing_versions[-1]}"
            
            # Get up to 4 oldest versions
            oldest_count=$((${#missing_versions[@]} - 1))
            if [ $oldest_count -gt 4 ]; then
              oldest_count=4
            fi
            oldest_versions=("${missing_versions[@]:0:$oldest_count}")
            
            # Combine: oldest versions first, then newest (to build newest last)
            missing_versions_limited=("${oldest_versions[@]}" "$newest_version")
          fi
          
          echo "Found ${#missing_versions[@]} missing version(s):"
          printf '%s\n' "${missing_versions[@]}"
          
          echo "Will publish ${#missing_versions_limited[@]} version(s) in this run:"
          printf '%s\n' "${missing_versions_limited[@]}"
          
          # Convert to JSON array
          missing_json=$(printf '%s\n' "${missing_versions_limited[@]}" | jq -R . | jq -s -c .)
          echo "missing_versions=${missing_json}" >> "$GITHUB_OUTPUT"
          echo "should_publish=true" >> "$GITHUB_OUTPUT"

  publish-image:
    runs-on: ${{ matrix.platform_config.runner }}
    needs: [check-version]
    if: |
      (github.event.inputs.force_publish == 'true' || needs.check-version.outputs.should_publish == 'true' || github.event_name == 'schedule' || github.event_name == 'release') &&
      needs.check-version.outputs.missing_versions != '[]'
    strategy:
      fail-fast: false
      matrix:
        version: ${{ fromJSON(needs.check-version.outputs.missing_versions) }}
        platform_config:
          - runner: ubuntu-latest
            platform: linux/amd64
            platform_tag: amd64
          - runner: ubuntu-24.04-arm
            platform: linux/arm64
            platform_tag: arm64
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_PASSWORD }}
      - name: Extract Docker metadata for tagging
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: bitovi/n8n-community-nodes
          tags: |
            type=raw,value=${{ matrix.version }}-${{ matrix.platform_config.platform_tag }}
            type=raw,value=latest-${{ matrix.platform_config.platform_tag }},enable=${{ matrix.version == needs.check-version.outputs.n8n_version }}
            type=semver,pattern={{version}}-${{ matrix.platform_config.platform_tag }},enable=${{ github.event_name == 'release' }}
            type=semver,pattern={{major}}.{{minor}}-${{ matrix.platform_config.platform_tag }},enable=${{ github.event_name == 'release' && !github.event.release.prerelease }}
      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: |
            ${{ steps.meta.outputs.labels }}
            io.n8n.version.base=${{ matrix.version }}
          platforms: ${{ matrix.platform_config.platform }}
          build-args: |
            N8N_VERSION=${{ matrix.version }}
  
  publish-manifest:
    runs-on: ubuntu-latest
    needs: [check-version, publish-image]
    if: |
      (github.event.inputs.force_publish == 'true' || needs.check-version.outputs.should_publish == 'true' || github.event_name == 'schedule' || github.event_name == 'release') &&
      needs.check-version.outputs.missing_versions != '[]'
    steps:
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_PASSWORD }}
      - name: Create and push multi-arch manifests
        run: |
          # Get the array of missing versions
          MISSING_VERSIONS='${{ needs.check-version.outputs.missing_versions }}'
          
          # Parse JSON array and create manifests for each version
          echo "$MISSING_VERSIONS" | jq -r '.[]' | while read -r VERSION; do
            echo "Creating manifest for version: $VERSION"
            docker buildx imagetools create -t bitovi/n8n-community-nodes:${VERSION} \
              bitovi/n8n-community-nodes:${VERSION}-amd64 \
              bitovi/n8n-community-nodes:${VERSION}-arm64
          done
          
          # Update the 'latest' tag to point to the newest version
          LATEST_VERSION=$(echo "$MISSING_VERSIONS" | jq -r '.[-1]')
          if [ -n "$LATEST_VERSION" ] && [ "$LATEST_VERSION" != "null" ]; then
            echo "Updating 'latest' tag to point to version: $LATEST_VERSION"
            docker buildx imagetools create -t bitovi/n8n-community-nodes:latest \
              bitovi/n8n-community-nodes:${LATEST_VERSION}-amd64 \
              bitovi/n8n-community-nodes:${LATEST_VERSION}-arm64
          fi
      - name: Create and push multi-arch manifest for releases
        if: github.event_name == 'release'
        run: |
          VERSION="${{ github.event.release.tag_name }}"
          docker buildx imagetools create -t bitovi/n8n-community-nodes:${VERSION} \
            bitovi/n8n-community-nodes:${VERSION}-amd64 \
            bitovi/n8n-community-nodes:${VERSION}-arm64
          
          # Extract major.minor if not a prerelease
          if [[ "${{ github.event.release.prerelease }}" != "true" ]]; then
            MAJOR_MINOR=$(echo ${VERSION} | sed -E 's/^([0-9]+\.[0-9]+)\..*/\1/')
            docker buildx imagetools create -t bitovi/n8n-community-nodes:${MAJOR_MINOR} \
              bitovi/n8n-community-nodes:${MAJOR_MINOR}-amd64 \
              bitovi/n8n-community-nodes:${MAJOR_MINOR}-arm64
          fi
